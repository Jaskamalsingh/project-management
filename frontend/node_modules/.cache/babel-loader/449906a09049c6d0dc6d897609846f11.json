{"ast":null,"code":"import T, { Fragment as J, createContext as K, useContext as G, useEffect as H, useMemo as Q, useRef as c, useState as B } from \"react\";\nimport { Features as fe, forwardRefWithAs as W, render as X, RenderStrategy as g } from '../../utils/render.js';\nimport { OpenClosedProvider as Te, State as O, useOpenClosed as Y } from '../../internal/open-closed.js';\nimport { match as R } from '../../utils/match.js';\nimport { useIsMounted as ce } from '../../hooks/use-is-mounted.js';\nimport { useIsoMorphicEffect as me } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as A } from '../../hooks/use-latest-value.js';\nimport { useServerHandoffComplete as Z } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as $ } from '../../hooks/use-sync-refs.js';\nimport { useTransition as pe } from '../../hooks/use-transition.js';\nimport { useEvent as y } from '../../hooks/use-event.js';\nimport { useDisposables as he } from '../../hooks/use-disposables.js';\nfunction x(r = \"\") {\n  return r.split(\" \").filter(e => e.trim().length > 1);\n}\nlet F = K(null);\nF.displayName = \"TransitionContext\";\nvar ve = (s => (s.Visible = \"visible\", s.Hidden = \"hidden\", s))(ve || {});\nfunction Ce() {\n  let r = G(F);\n  if (r === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return r;\n}\nfunction ge() {\n  let r = G(M);\n  if (r === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return r;\n}\nlet M = K(null);\nM.displayName = \"NestingContext\";\nfunction I(r) {\n  return \"children\" in r ? I(r.children) : r.current.filter(({\n    el: e\n  }) => e.current !== null).filter(({\n    state: e\n  }) => e === \"visible\").length > 0;\n}\nfunction ee(r, e) {\n  let s = A(r),\n    n = c([]),\n    m = ce(),\n    D = he(),\n    b = y((l, i = g.Hidden) => {\n      let t = n.current.findIndex(({\n        el: o\n      }) => o === l);\n      t !== -1 && (R(i, {\n        [g.Unmount]() {\n          n.current.splice(t, 1);\n        },\n        [g.Hidden]() {\n          n.current[t].state = \"hidden\";\n        }\n      }), D.microTask(() => {\n        var o;\n        !I(n) && m.current && ((o = s.current) == null || o.call(s));\n      }));\n    }),\n    E = y(l => {\n      let i = n.current.find(({\n        el: t\n      }) => t === l);\n      return i ? i.state !== \"visible\" && (i.state = \"visible\") : n.current.push({\n        el: l,\n        state: \"visible\"\n      }), () => b(l, g.Unmount);\n    }),\n    S = c([]),\n    u = c(Promise.resolve()),\n    p = c({\n      enter: [],\n      leave: [],\n      idle: []\n    }),\n    d = y((l, i, t) => {\n      S.current.splice(0), e && (e.chains.current[i] = e.chains.current[i].filter(([o]) => o !== l)), e == null || e.chains.current[i].push([l, new Promise(o => {\n        S.current.push(o);\n      })]), e == null || e.chains.current[i].push([l, new Promise(o => {\n        Promise.all(p.current[i].map(([f, a]) => a)).then(() => o());\n      })]), i === \"enter\" ? u.current = u.current.then(() => e == null ? void 0 : e.wait.current).then(() => t(i)) : t(i);\n    }),\n    h = y((l, i, t) => {\n      Promise.all(p.current[i].splice(0).map(([o, f]) => f)).then(() => {\n        var o;\n        (o = S.current.shift()) == null || o();\n      }).then(() => t(i));\n    });\n  return Q(() => ({\n    children: n,\n    register: E,\n    unregister: b,\n    onStart: d,\n    onStop: h,\n    wait: u,\n    chains: p\n  }), [E, b, n, d, h, p, u]);\n}\nfunction be() {}\nlet Ee = [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\"];\nfunction te(r) {\n  var s;\n  let e = {};\n  for (let n of Ee) e[n] = (s = r[n]) != null ? s : be;\n  return e;\n}\nfunction Se(r) {\n  let e = c(te(r));\n  return H(() => {\n    e.current = te(r);\n  }, [r]), e;\n}\nlet xe = \"div\",\n  ne = fe.RenderStrategy,\n  re = W(function (e, s) {\n    let {\n        beforeEnter: n,\n        afterEnter: m,\n        beforeLeave: D,\n        afterLeave: b,\n        enter: E,\n        enterFrom: S,\n        enterTo: u,\n        entered: p,\n        leave: d,\n        leaveFrom: h,\n        leaveTo: l,\n        ...i\n      } = e,\n      t = c(null),\n      o = $(t, s),\n      f = i.unmount ? g.Unmount : g.Hidden,\n      {\n        show: a,\n        appear: P,\n        initial: ie\n      } = Ce(),\n      [v, _] = B(a ? \"visible\" : \"hidden\"),\n      z = ge(),\n      {\n        register: N,\n        unregister: V\n      } = z,\n      j = c(null);\n    H(() => N(t), [N, t]), H(() => {\n      if (f === g.Hidden && !!t.current) {\n        if (a && v !== \"visible\") {\n          _(\"visible\");\n          return;\n        }\n        return R(v, {\n          [\"hidden\"]: () => V(t),\n          [\"visible\"]: () => N(t)\n        });\n      }\n    }, [v, t, N, V, a, f]);\n    let oe = A({\n        enter: x(E),\n        enterFrom: x(S),\n        enterTo: x(u),\n        entered: x(p),\n        leave: x(d),\n        leaveFrom: x(h),\n        leaveTo: x(l)\n      }),\n      L = Se({\n        beforeEnter: n,\n        afterEnter: m,\n        beforeLeave: D,\n        afterLeave: b\n      }),\n      U = Z();\n    H(() => {\n      if (U && v === \"visible\" && t.current === null) throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n    }, [t, v, U]);\n    let k = ie && !P,\n      se = (() => !U || k || j.current === a ? \"idle\" : a ? \"enter\" : \"leave\")(),\n      le = y(C => R(C, {\n        enter: () => L.current.beforeEnter(),\n        leave: () => L.current.beforeLeave(),\n        idle: () => {}\n      })),\n      ae = y(C => R(C, {\n        enter: () => L.current.afterEnter(),\n        leave: () => L.current.afterLeave(),\n        idle: () => {}\n      })),\n      w = ee(() => {\n        _(\"hidden\"), V(t);\n      }, z);\n    pe({\n      container: t,\n      classes: oe,\n      direction: se,\n      onStart: A(C => {\n        w.onStart(t, C, le);\n      }),\n      onStop: A(C => {\n        w.onStop(t, C, ae), C === \"leave\" && !I(w) && (_(\"hidden\"), V(t));\n      })\n    }), H(() => {\n      !k || (f === g.Hidden ? j.current = null : j.current = a);\n    }, [a, k, v]);\n    let ue = i,\n      de = {\n        ref: o\n      };\n    return T.createElement(M.Provider, {\n      value: w\n    }, T.createElement(Te, {\n      value: R(v, {\n        [\"visible\"]: O.Open,\n        [\"hidden\"]: O.Closed\n      })\n    }, X({\n      ourProps: de,\n      theirProps: ue,\n      defaultTag: xe,\n      features: ne,\n      visible: v === \"visible\",\n      name: \"Transition.Child\"\n    })));\n  }),\n  q = W(function (e, s) {\n    let {\n        show: n,\n        appear: m = !1,\n        unmount: D,\n        ...b\n      } = e,\n      E = c(null),\n      S = $(E, s);\n    Z();\n    let u = Y();\n    if (n === void 0 && u !== null && (n = R(u, {\n      [O.Open]: !0,\n      [O.Closed]: !1\n    })), ![!0, !1].includes(n)) throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n    let [p, d] = B(n ? \"visible\" : \"hidden\"),\n      h = ee(() => {\n        d(\"hidden\");\n      }),\n      [l, i] = B(!0),\n      t = c([n]);\n    me(() => {\n      l !== !1 && t.current[t.current.length - 1] !== n && (t.current.push(n), i(!1));\n    }, [t, n]);\n    let o = Q(() => ({\n      show: n,\n      appear: m,\n      initial: l\n    }), [n, m, l]);\n    H(() => {\n      if (n) d(\"visible\");else if (!I(h)) d(\"hidden\");else {\n        let a = E.current;\n        if (!a) return;\n        let P = a.getBoundingClientRect();\n        P.x === 0 && P.y === 0 && P.width === 0 && P.height === 0 && d(\"hidden\");\n      }\n    }, [n, h]);\n    let f = {\n      unmount: D\n    };\n    return T.createElement(M.Provider, {\n      value: h\n    }, T.createElement(F.Provider, {\n      value: o\n    }, X({\n      ourProps: {\n        ...f,\n        as: J,\n        children: T.createElement(re, {\n          ref: S,\n          ...f,\n          ...b\n        })\n      },\n      theirProps: {},\n      defaultTag: J,\n      features: ne,\n      visible: p === \"visible\",\n      name: \"Transition\"\n    })));\n  }),\n  Pe = W(function (e, s) {\n    let n = G(F) !== null,\n      m = Y() !== null;\n    return T.createElement(T.Fragment, null, !n && m ? T.createElement(q, {\n      ref: s,\n      ...e\n    }) : T.createElement(re, {\n      ref: s,\n      ...e\n    }));\n  }),\n  We = Object.assign(q, {\n    Child: Pe,\n    Root: q\n  });\nexport { We as Transition };","map":null,"metadata":{},"sourceType":"module"}