{"ast":null,"code":"import { Fragment as c, cloneElement as P, createElement as b, forwardRef as E, isValidElement as x } from \"react\";\nimport { match as R } from './match.js';\nvar S = (a => (a[a.None = 0] = \"None\", a[a.RenderStrategy = 1] = \"RenderStrategy\", a[a.Static = 2] = \"Static\", a))(S || {}),\n  j = (e => (e[e.Unmount = 0] = \"Unmount\", e[e.Hidden = 1] = \"Hidden\", e))(j || {});\nfunction $({\n  ourProps: r,\n  theirProps: t,\n  slot: e,\n  defaultTag: a,\n  features: o,\n  visible: n = !0,\n  name: l\n}) {\n  let s = T(t, r);\n  if (n) return p(s, e, a, l);\n  let u = o != null ? o : 0;\n  if (u & 2) {\n    let {\n      static: i = !1,\n      ...d\n    } = s;\n    if (i) return p(d, e, a, l);\n  }\n  if (u & 1) {\n    let {\n      unmount: i = !0,\n      ...d\n    } = s;\n    return R(i ? 0 : 1, {\n      [0]() {\n        return null;\n      },\n      [1]() {\n        return p({\n          ...d,\n          hidden: !0,\n          style: {\n            display: \"none\"\n          }\n        }, e, a, l);\n      }\n    });\n  }\n  return p(s, e, a, l);\n}\nfunction p(r, t = {}, e, a) {\n  let {\n      as: o = e,\n      children: n,\n      refName: l = \"ref\",\n      ...s\n    } = m(r, [\"unmount\", \"static\"]),\n    u = r.ref !== void 0 ? {\n      [l]: r.ref\n    } : {},\n    i = typeof n == \"function\" ? n(t) : n;\n  s.className && typeof s.className == \"function\" && (s.className = s.className(t));\n  let d = {};\n  if (t) {\n    let f = !1,\n      y = [];\n    for (let [h, g] of Object.entries(t)) typeof g == \"boolean\" && (f = !0), g === !0 && y.push(h);\n    f && (d[\"data-headlessui-state\"] = y.join(\" \"));\n  }\n  if (o === c && Object.keys(F(s)).length > 0) {\n    if (!x(i) || Array.isArray(i) && i.length > 1) throw new Error(['Passing props on \"Fragment\"!', \"\", `The current component <${a} /> is rendering a \"Fragment\".`, \"However we need to passthrough the following props:\", Object.keys(s).map(f => `  - ${f}`).join(`\n`), \"\", \"You can apply a few solutions:\", ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', \"Render a single element as the child so that we can forward the props onto that element.\"].map(f => `  - ${f}`).join(`\n`)].join(`\n`));\n    return P(i, Object.assign({}, T(i.props, F(m(s, [\"ref\"]))), d, u, w(i.ref, u.ref)));\n  }\n  return b(o, Object.assign({}, m(s, [\"ref\"]), o !== c && u, o !== c && d), i);\n}\nfunction w(...r) {\n  return {\n    ref: r.every(t => t == null) ? void 0 : t => {\n      for (let e of r) e != null && (typeof e == \"function\" ? e(t) : e.current = t);\n    }\n  };\n}\nfunction T(...r) {\n  var a;\n  if (r.length === 0) return {};\n  if (r.length === 1) return r[0];\n  let t = {},\n    e = {};\n  for (let o of r) for (let n in o) n.startsWith(\"on\") && typeof o[n] == \"function\" ? ((a = e[n]) != null || (e[n] = []), e[n].push(o[n])) : t[n] = o[n];\n  if (t.disabled || t[\"aria-disabled\"]) return Object.assign(t, Object.fromEntries(Object.keys(e).map(o => [o, void 0])));\n  for (let o in e) Object.assign(t, {\n    [o](n, ...l) {\n      let s = e[o];\n      for (let u of s) {\n        if ((n instanceof Event || (n == null ? void 0 : n.nativeEvent) instanceof Event) && n.defaultPrevented) return;\n        u(n, ...l);\n      }\n    }\n  });\n  return t;\n}\nfunction C(r) {\n  var t;\n  return Object.assign(E(r), {\n    displayName: (t = r.displayName) != null ? t : r.name\n  });\n}\nfunction F(r) {\n  let t = Object.assign({}, r);\n  for (let e in t) t[e] === void 0 && delete t[e];\n  return t;\n}\nfunction m(r, t = []) {\n  let e = Object.assign({}, r);\n  for (let a of t) a in e && delete e[a];\n  return e;\n}\nexport { S as Features, j as RenderStrategy, F as compact, C as forwardRefWithAs, $ as render };","map":null,"metadata":{},"sourceType":"module"}