{"ast":null,"code":"import M, { Fragment as Z, createContext as G, useContext as j, useMemo as L, useReducer as ee, useRef as H } from \"react\";\nimport { render as v, Features as q, forwardRefWithAs as C } from '../../utils/render.js';\nimport { useId as J } from '../../hooks/use-id.js';\nimport { match as Q } from '../../utils/match.js';\nimport { Keys as b } from '../../components/keyboard.js';\nimport { focusIn as I, Focus as T, sortByDomNode as X } from '../../utils/focus-management.js';\nimport { useIsoMorphicEffect as W } from '../../hooks/use-iso-morphic-effect.js';\nimport { useSyncRefs as F } from '../../hooks/use-sync-refs.js';\nimport { useResolveButtonType as te } from '../../hooks/use-resolve-button-type.js';\nimport { useLatestValue as N } from '../../hooks/use-latest-value.js';\nimport { FocusSentinel as re } from '../../internal/focus-sentinel.js';\nimport { useEvent as U } from '../../hooks/use-event.js';\nimport { microTask as ne } from '../../utils/micro-task.js';\nimport { Hidden as ae } from '../../internal/hidden.js';\nvar le = (n => (n[n.SetSelectedIndex = 0] = \"SetSelectedIndex\", n[n.RegisterTab = 1] = \"RegisterTab\", n[n.UnregisterTab = 2] = \"UnregisterTab\", n[n.RegisterPanel = 3] = \"RegisterPanel\", n[n.UnregisterPanel = 4] = \"UnregisterPanel\", n))(le || {});\nlet oe = {\n    [0](e, t) {\n      let r = e.tabs.filter(d => {\n        var l;\n        return !((l = d.current) != null && l.hasAttribute(\"disabled\"));\n      });\n      if (t.index < 0) return {\n        ...e,\n        selectedIndex: e.tabs.indexOf(r[0])\n      };\n      if (t.index > e.tabs.length) return {\n        ...e,\n        selectedIndex: e.tabs.indexOf(r[r.length - 1])\n      };\n      let o = e.tabs.slice(0, t.index),\n        n = [...e.tabs.slice(t.index), ...o].find(d => r.includes(d));\n      return n ? {\n        ...e,\n        selectedIndex: e.tabs.indexOf(n)\n      } : e;\n    },\n    [1](e, t) {\n      var n;\n      if (e.tabs.includes(t.tab)) return e;\n      let r = e.tabs[e.selectedIndex],\n        o = X([...e.tabs, t.tab], d => d.current),\n        c = (n = o.indexOf(r)) != null ? n : e.selectedIndex;\n      return c === -1 && (c = e.selectedIndex), {\n        ...e,\n        tabs: o,\n        selectedIndex: c\n      };\n    },\n    [2](e, t) {\n      return {\n        ...e,\n        tabs: e.tabs.filter(r => r !== t.tab)\n      };\n    },\n    [3](e, t) {\n      return e.panels.includes(t.panel) ? e : {\n        ...e,\n        panels: X([...e.panels, t.panel], r => r.current)\n      };\n    },\n    [4](e, t) {\n      return {\n        ...e,\n        panels: e.panels.filter(r => r !== t.panel)\n      };\n    }\n  },\n  B = G(null);\nB.displayName = \"TabsSSRContext\";\nfunction K(e) {\n  let t = j(B);\n  if (t === null) {\n    let r = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(r, K), r;\n  }\n  return t;\n}\nlet $ = G(null);\n$.displayName = \"TabsDataContext\";\nfunction _(e) {\n  let t = j($);\n  if (t === null) {\n    let r = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(r, _), r;\n  }\n  return t;\n}\nlet z = G(null);\nz.displayName = \"TabsActionsContext\";\nfunction V(e) {\n  let t = j(z);\n  if (t === null) {\n    let r = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(r, V), r;\n  }\n  return t;\n}\nfunction se(e, t) {\n  return Q(t.type, oe, e, t);\n}\nlet ie = Z,\n  ue = C(function (t, r) {\n    let {\n      defaultIndex: o = 0,\n      vertical: c = !1,\n      manual: n = !1,\n      onChange: d,\n      selectedIndex: l = null,\n      ...P\n    } = t;\n    const f = c ? \"vertical\" : \"horizontal\",\n      y = n ? \"manual\" : \"auto\";\n    let u = l !== null,\n      x = F(r),\n      [s, i] = ee(se, {\n        selectedIndex: l != null ? l : o,\n        tabs: [],\n        panels: []\n      }),\n      g = L(() => ({\n        selectedIndex: s.selectedIndex\n      }), [s.selectedIndex]),\n      R = N(d || (() => {})),\n      E = N(s.tabs),\n      m = L(() => ({\n        orientation: f,\n        activation: y,\n        ...s\n      }), [f, y, s]),\n      A = N(u ? t.selectedIndex : s.selectedIndex),\n      O = L(() => ({\n        registerTab(p) {\n          return i({\n            type: 1,\n            tab: p\n          }), () => i({\n            type: 2,\n            tab: p\n          });\n        },\n        registerPanel(p) {\n          return i({\n            type: 3,\n            panel: p\n          }), () => i({\n            type: 4,\n            panel: p\n          });\n        },\n        change(p) {\n          A.current !== p && R.current(p), u || i({\n            type: 0,\n            index: p\n          });\n        }\n      }), [i, u]);\n    W(() => {\n      i({\n        type: 0,\n        index: l != null ? l : o\n      });\n    }, [l]);\n    let w = H({\n        tabs: [],\n        panels: []\n      }),\n      k = {\n        ref: x\n      };\n    return M.createElement(B.Provider, {\n      value: w\n    }, M.createElement(z.Provider, {\n      value: O\n    }, M.createElement($.Provider, {\n      value: m\n    }, m.tabs.length <= 0 && M.createElement(re, {\n      onFocus: () => {\n        var p, h;\n        for (let D of E.current) if (((p = D.current) == null ? void 0 : p.tabIndex) === 0) return (h = D.current) == null || h.focus(), !0;\n        return !1;\n      }\n    }), v({\n      ourProps: k,\n      theirProps: P,\n      slot: g,\n      defaultTag: ie,\n      name: \"Tabs\"\n    }))));\n  }),\n  ce = \"div\",\n  de = C(function (t, r) {\n    let {\n        orientation: o,\n        selectedIndex: c\n      } = _(\"Tab.List\"),\n      n = F(r);\n    return v({\n      ourProps: {\n        ref: n,\n        role: \"tablist\",\n        \"aria-orientation\": o\n      },\n      theirProps: t,\n      slot: {\n        selectedIndex: c\n      },\n      defaultTag: ce,\n      name: \"Tabs.List\"\n    });\n  }),\n  pe = \"button\",\n  fe = C(function (t, r) {\n    var h, D;\n    let o = `headlessui-tabs-tab-${J()}`,\n      {\n        orientation: c,\n        activation: n,\n        selectedIndex: d,\n        tabs: l,\n        panels: P\n      } = _(\"Tab\"),\n      f = V(\"Tab\"),\n      y = K(\"Tab\"),\n      u = H(null),\n      x = F(u, r);\n    W(() => f.registerTab(u), [f, u]);\n    let s = y.current.tabs.indexOf(o);\n    s === -1 && (s = y.current.tabs.push(o) - 1);\n    let i = l.indexOf(u);\n    i === -1 && (i = s);\n    let g = i === d,\n      R = U(a => {\n        let S = l.map(Y => Y.current).filter(Boolean);\n        if (a.key === b.Space || a.key === b.Enter) {\n          a.preventDefault(), a.stopPropagation(), f.change(i);\n          return;\n        }\n        switch (a.key) {\n          case b.Home:\n          case b.PageUp:\n            return a.preventDefault(), a.stopPropagation(), I(S, T.First);\n          case b.End:\n          case b.PageDown:\n            return a.preventDefault(), a.stopPropagation(), I(S, T.Last);\n        }\n        if (Q(c, {\n          vertical() {\n            if (a.key === b.ArrowUp) return I(S, T.Previous | T.WrapAround);\n            if (a.key === b.ArrowDown) return I(S, T.Next | T.WrapAround);\n          },\n          horizontal() {\n            if (a.key === b.ArrowLeft) return I(S, T.Previous | T.WrapAround);\n            if (a.key === b.ArrowRight) return I(S, T.Next | T.WrapAround);\n          }\n        })) return a.preventDefault();\n      }),\n      E = U(() => {\n        var a;\n        (a = u.current) == null || a.focus();\n      }),\n      m = H(!1),\n      A = U(() => {\n        var a;\n        m.current || (m.current = !0, (a = u.current) == null || a.focus(), f.change(i), ne(() => {\n          m.current = !1;\n        }));\n      }),\n      O = U(a => {\n        a.preventDefault();\n      }),\n      w = L(() => ({\n        selected: g\n      }), [g]),\n      k = t,\n      p = {\n        ref: x,\n        onKeyDown: R,\n        onFocus: n === \"manual\" ? E : A,\n        onMouseDown: O,\n        onClick: A,\n        id: o,\n        role: \"tab\",\n        type: te(t, u),\n        \"aria-controls\": (D = (h = P[i]) == null ? void 0 : h.current) == null ? void 0 : D.id,\n        \"aria-selected\": g,\n        tabIndex: g ? 0 : -1\n      };\n    return v({\n      ourProps: p,\n      theirProps: k,\n      slot: w,\n      defaultTag: pe,\n      name: \"Tabs.Tab\"\n    });\n  }),\n  be = \"div\",\n  Te = C(function (t, r) {\n    let {\n        selectedIndex: o\n      } = _(\"Tab.Panels\"),\n      c = F(r),\n      n = L(() => ({\n        selectedIndex: o\n      }), [o]);\n    return v({\n      ourProps: {\n        ref: c\n      },\n      theirProps: t,\n      slot: n,\n      defaultTag: be,\n      name: \"Tabs.Panels\"\n    });\n  }),\n  me = \"div\",\n  Pe = q.RenderStrategy | q.Static,\n  xe = C(function (t, r) {\n    var E, m, A;\n    let {\n        selectedIndex: o,\n        tabs: c,\n        panels: n\n      } = _(\"Tab.Panel\"),\n      d = V(\"Tab.Panel\"),\n      l = K(\"Tab.Panel\"),\n      P = `headlessui-tabs-panel-${J()}`,\n      f = H(null),\n      y = F(f, r);\n    W(() => d.registerPanel(f), [d, f]);\n    let u = l.current.panels.indexOf(P);\n    u === -1 && (u = l.current.panels.push(P) - 1);\n    let x = n.indexOf(f);\n    x === -1 && (x = u);\n    let s = x === o,\n      i = L(() => ({\n        selected: s\n      }), [s]),\n      g = t,\n      R = {\n        ref: y,\n        id: P,\n        role: \"tabpanel\",\n        \"aria-labelledby\": (m = (E = c[x]) == null ? void 0 : E.current) == null ? void 0 : m.id,\n        tabIndex: s ? 0 : -1\n      };\n    return !s && ((A = t.unmount) != null ? A : !0) ? M.createElement(ae, {\n      as: \"span\",\n      ...R\n    }) : v({\n      ourProps: R,\n      theirProps: g,\n      slot: i,\n      defaultTag: me,\n      features: Pe,\n      visible: s,\n      name: \"Tabs.Panel\"\n    });\n  }),\n  We = Object.assign(fe, {\n    Group: ue,\n    List: de,\n    Panels: Te,\n    Panel: xe\n  });\nexport { We as Tab };","map":null,"metadata":{},"sourceType":"module"}