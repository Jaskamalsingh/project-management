{"ast":null,"code":"import F, { createContext as V, createRef as pe, useContext as $, useEffect as U, useMemo as I, useReducer as fe, useRef as Y, useState as Pe } from \"react\";\nimport { match as H } from '../../utils/match.js';\nimport { forwardRefWithAs as W, render as j, Features as q } from '../../utils/render.js';\nimport { optionalRef as de, useSyncRefs as x } from '../../hooks/use-sync-refs.js';\nimport { useId as G } from '../../hooks/use-id.js';\nimport { Keys as h } from '../keyboard.js';\nimport { isDisabledReactIssue7711 as se } from '../../utils/bugs.js';\nimport { getFocusableElements as ve, Focus as k, focusIn as _, isFocusableElement as Te, FocusableMode as me } from '../../utils/focus-management.js';\nimport { OpenClosedProvider as ye, State as z, useOpenClosed as ie } from '../../internal/open-closed.js';\nimport { useResolveButtonType as Ee } from '../../hooks/use-resolve-button-type.js';\nimport { useOutsideClick as Se } from '../../hooks/use-outside-click.js';\nimport { getOwnerDocument as be } from '../../utils/owner.js';\nimport { useOwnerDocument as Q } from '../../hooks/use-owner.js';\nimport { useEventListener as ge } from '../../hooks/use-event-listener.js';\nimport { Hidden as X, Features as Z } from '../../internal/hidden.js';\nimport { useEvent as b } from '../../hooks/use-event.js';\nimport { useTabDirection as ue, Direction as w } from '../../hooks/use-tab-direction.js';\nimport '../../utils/micro-task.js';\nvar Ae = (c => (c[c.Open = 0] = \"Open\", c[c.Closed = 1] = \"Closed\", c))(Ae || {}),\n  Ce = (n => (n[n.TogglePopover = 0] = \"TogglePopover\", n[n.ClosePopover = 1] = \"ClosePopover\", n[n.SetButton = 2] = \"SetButton\", n[n.SetButtonId = 3] = \"SetButtonId\", n[n.SetPanel = 4] = \"SetPanel\", n[n.SetPanelId = 5] = \"SetPanelId\", n))(Ce || {});\nlet Re = {\n    [0]: r => ({\n      ...r,\n      popoverState: H(r.popoverState, {\n        [0]: 1,\n        [1]: 0\n      })\n    }),\n    [1](r) {\n      return r.popoverState === 1 ? r : {\n        ...r,\n        popoverState: 1\n      };\n    },\n    [2](r, t) {\n      return r.button === t.button ? r : {\n        ...r,\n        button: t.button\n      };\n    },\n    [3](r, t) {\n      return r.buttonId === t.buttonId ? r : {\n        ...r,\n        buttonId: t.buttonId\n      };\n    },\n    [4](r, t) {\n      return r.panel === t.panel ? r : {\n        ...r,\n        panel: t.panel\n      };\n    },\n    [5](r, t) {\n      return r.panelId === t.panelId ? r : {\n        ...r,\n        panelId: t.panelId\n      };\n    }\n  },\n  ee = V(null);\nee.displayName = \"PopoverContext\";\nfunction J(r) {\n  let t = $(ee);\n  if (t === null) {\n    let c = new Error(`<${r} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(c, J), c;\n  }\n  return t;\n}\nlet te = V(null);\nte.displayName = \"PopoverAPIContext\";\nfunction oe(r) {\n  let t = $(te);\n  if (t === null) {\n    let c = new Error(`<${r} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(c, oe), c;\n  }\n  return t;\n}\nlet re = V(null);\nre.displayName = \"PopoverGroupContext\";\nfunction ce() {\n  return $(re);\n}\nlet ne = V(null);\nne.displayName = \"PopoverPanelContext\";\nfunction Oe() {\n  return $(ne);\n}\nfunction Me(r, t) {\n  return H(t.type, Re, r, t);\n}\nlet Le = \"div\",\n  Fe = W(function (t, c) {\n    var R;\n    let o = `headlessui-popover-button-${G()}`,\n      d = `headlessui-popover-panel-${G()}`,\n      a = Y(null),\n      n = x(c, de(e => {\n        a.current = e;\n      })),\n      g = fe(Me, {\n        popoverState: 1,\n        button: null,\n        buttonId: o,\n        panel: null,\n        panelId: d,\n        beforePanelSentinel: pe(),\n        afterPanelSentinel: pe()\n      }),\n      [{\n        popoverState: m,\n        button: l,\n        panel: v,\n        beforePanelSentinel: p,\n        afterPanelSentinel: B\n      }, s] = g,\n      T = Q((R = a.current) != null ? R : l);\n    U(() => s({\n      type: 3,\n      buttonId: o\n    }), [o, s]), U(() => s({\n      type: 5,\n      panelId: d\n    }), [d, s]);\n    let f = I(() => {\n        if (!l || !v) return !1;\n        for (let e of document.querySelectorAll(\"body > *\")) if (Number(e == null ? void 0 : e.contains(l)) ^ Number(e == null ? void 0 : e.contains(v))) return !0;\n        return !1;\n      }, [l, v]),\n      P = I(() => ({\n        buttonId: o,\n        panelId: d,\n        close: () => s({\n          type: 1\n        })\n      }), [o, d, s]),\n      y = ce(),\n      A = y == null ? void 0 : y.registerPopover,\n      M = b(() => {\n        var e;\n        return (e = y == null ? void 0 : y.isFocusWithinPopoverGroup()) != null ? e : (T == null ? void 0 : T.activeElement) && ((l == null ? void 0 : l.contains(T.activeElement)) || (v == null ? void 0 : v.contains(T.activeElement)));\n      });\n    U(() => A == null ? void 0 : A(P), [A, P]), ge(T == null ? void 0 : T.defaultView, \"focus\", e => {\n      var i, S, O, N;\n      m === 0 && (M() || !l || !v || (S = (i = p.current) == null ? void 0 : i.contains) != null && S.call(i, e.target) || (N = (O = B.current) == null ? void 0 : O.contains) != null && N.call(O, e.target) || s({\n        type: 1\n      }));\n    }, !0), Se([l, v], (e, i) => {\n      s({\n        type: 1\n      }), Te(i, me.Loose) || (e.preventDefault(), l == null || l.focus());\n    }, m === 0);\n    let L = b(e => {\n        s({\n          type: 1\n        });\n        let i = (() => e ? e instanceof HTMLElement ? e : \"current\" in e && e.current instanceof HTMLElement ? e.current : l : l)();\n        i == null || i.focus();\n      }),\n      D = I(() => ({\n        close: L,\n        isPortalled: f\n      }), [L, f]),\n      u = I(() => ({\n        open: m === 0,\n        close: L\n      }), [m, L]),\n      E = t,\n      C = {\n        ref: n\n      };\n    return F.createElement(ee.Provider, {\n      value: g\n    }, F.createElement(te.Provider, {\n      value: D\n    }, F.createElement(ye, {\n      value: H(m, {\n        [0]: z.Open,\n        [1]: z.Closed\n      })\n    }, j({\n      ourProps: C,\n      theirProps: E,\n      slot: u,\n      defaultTag: Le,\n      name: \"Popover\"\n    }))));\n  }),\n  Ie = \"button\",\n  Be = W(function (t, c) {\n    let [o, d] = J(\"Popover.Button\"),\n      {\n        isPortalled: a\n      } = oe(\"Popover.Button\"),\n      n = Y(null),\n      g = `headlessui-focus-sentinel-${G()}`,\n      m = ce(),\n      l = m == null ? void 0 : m.closeOthers,\n      v = Oe(),\n      p = v === null ? !1 : v === o.panelId,\n      B = x(n, c, p ? null : e => d({\n        type: 2,\n        button: e\n      })),\n      s = x(n, c),\n      T = Q(n),\n      f = b(e => {\n        var i, S, O;\n        if (p) {\n          if (o.popoverState === 1) return;\n          switch (e.key) {\n            case h.Space:\n            case h.Enter:\n              e.preventDefault(), (S = (i = e.target).click) == null || S.call(i), d({\n                type: 1\n              }), (O = o.button) == null || O.focus();\n              break;\n          }\n        } else switch (e.key) {\n          case h.Space:\n          case h.Enter:\n            e.preventDefault(), e.stopPropagation(), o.popoverState === 1 && (l == null || l(o.buttonId)), d({\n              type: 0\n            });\n            break;\n          case h.Escape:\n            if (o.popoverState !== 0) return l == null ? void 0 : l(o.buttonId);\n            if (!n.current || (T == null ? void 0 : T.activeElement) && !n.current.contains(T.activeElement)) return;\n            e.preventDefault(), e.stopPropagation(), d({\n              type: 1\n            });\n            break;\n        }\n      }),\n      P = b(e => {\n        p || e.key === h.Space && e.preventDefault();\n      }),\n      y = b(e => {\n        var i, S;\n        se(e.currentTarget) || t.disabled || (p ? (d({\n          type: 1\n        }), (i = o.button) == null || i.focus()) : (e.preventDefault(), e.stopPropagation(), o.popoverState === 1 && (l == null || l(o.buttonId)), d({\n          type: 0\n        }), (S = o.button) == null || S.focus()));\n      }),\n      A = b(e => {\n        e.preventDefault(), e.stopPropagation();\n      }),\n      M = o.popoverState === 0,\n      L = I(() => ({\n        open: M\n      }), [M]),\n      D = Ee(t, n),\n      u = t,\n      E = p ? {\n        ref: s,\n        type: D,\n        onKeyDown: f,\n        onClick: y\n      } : {\n        ref: B,\n        id: o.buttonId,\n        type: D,\n        \"aria-expanded\": t.disabled ? void 0 : o.popoverState === 0,\n        \"aria-controls\": o.panel ? o.panelId : void 0,\n        onKeyDown: f,\n        onKeyUp: P,\n        onClick: y,\n        onMouseDown: A\n      },\n      C = ue(),\n      R = b(() => {\n        let e = o.panel;\n        if (!e) return;\n        function i() {\n          H(C.current, {\n            [w.Forwards]: () => _(e, k.First),\n            [w.Backwards]: () => _(e, k.Last)\n          });\n        }\n        i();\n      });\n    return F.createElement(F.Fragment, null, j({\n      ourProps: E,\n      theirProps: u,\n      slot: L,\n      defaultTag: Ie,\n      name: \"Popover.Button\"\n    }), M && !p && a && F.createElement(X, {\n      id: g,\n      features: Z.Focusable,\n      as: \"button\",\n      type: \"button\",\n      onFocus: R\n    }));\n  }),\n  he = \"div\",\n  De = q.RenderStrategy | q.Static,\n  He = W(function (t, c) {\n    let [{\n        popoverState: o\n      }, d] = J(\"Popover.Overlay\"),\n      a = x(c),\n      n = `headlessui-popover-overlay-${G()}`,\n      g = ie(),\n      m = (() => g !== null ? g === z.Open : o === 0)(),\n      l = b(s => {\n        if (se(s.currentTarget)) return s.preventDefault();\n        d({\n          type: 1\n        });\n      }),\n      v = I(() => ({\n        open: o === 0\n      }), [o]);\n    return j({\n      ourProps: {\n        ref: a,\n        id: n,\n        \"aria-hidden\": !0,\n        onClick: l\n      },\n      theirProps: t,\n      slot: v,\n      defaultTag: he,\n      features: De,\n      visible: m,\n      name: \"Popover.Overlay\"\n    });\n  }),\n  xe = \"div\",\n  Ge = q.RenderStrategy | q.Static,\n  ke = W(function (t, c) {\n    let {\n        focus: o = !1,\n        ...d\n      } = t,\n      [a, n] = J(\"Popover.Panel\"),\n      {\n        close: g,\n        isPortalled: m\n      } = oe(\"Popover.Panel\"),\n      l = `headlessui-focus-sentinel-before-${G()}`,\n      v = `headlessui-focus-sentinel-after-${G()}`,\n      p = Y(null),\n      B = x(p, c, u => {\n        n({\n          type: 4,\n          panel: u\n        });\n      }),\n      s = Q(p),\n      T = ie(),\n      f = (() => T !== null ? T === z.Open : a.popoverState === 0)(),\n      P = b(u => {\n        var E;\n        switch (u.key) {\n          case h.Escape:\n            if (a.popoverState !== 0 || !p.current || (s == null ? void 0 : s.activeElement) && !p.current.contains(s.activeElement)) return;\n            u.preventDefault(), u.stopPropagation(), n({\n              type: 1\n            }), (E = a.button) == null || E.focus();\n            break;\n        }\n      });\n    U(() => {\n      var u;\n      t.static || a.popoverState === 1 && ((u = t.unmount) != null ? u : !0) && n({\n        type: 4,\n        panel: null\n      });\n    }, [a.popoverState, t.unmount, t.static, n]), U(() => {\n      if (!o || a.popoverState !== 0 || !p.current) return;\n      let u = s == null ? void 0 : s.activeElement;\n      p.current.contains(u) || _(p.current, k.First);\n    }, [o, p, a.popoverState]);\n    let y = I(() => ({\n        open: a.popoverState === 0,\n        close: g\n      }), [a, g]),\n      A = {\n        ref: B,\n        id: a.panelId,\n        onKeyDown: P,\n        onBlur: o && a.popoverState === 0 ? u => {\n          var C, R, e, i, S;\n          let E = u.relatedTarget;\n          !E || !p.current || (C = p.current) != null && C.contains(E) || (n({\n            type: 1\n          }), (((e = (R = a.beforePanelSentinel.current) == null ? void 0 : R.contains) == null ? void 0 : e.call(R, E)) || ((S = (i = a.afterPanelSentinel.current) == null ? void 0 : i.contains) == null ? void 0 : S.call(i, E))) && E.focus({\n            preventScroll: !0\n          }));\n        } : void 0,\n        tabIndex: -1\n      },\n      M = ue(),\n      L = b(() => {\n        let u = p.current;\n        if (!u) return;\n        function E() {\n          H(M.current, {\n            [w.Forwards]: () => {\n              _(u, k.First);\n            },\n            [w.Backwards]: () => {\n              var C;\n              (C = a.button) == null || C.focus({\n                preventScroll: !0\n              });\n            }\n          });\n        }\n        E();\n      }),\n      D = b(() => {\n        let u = p.current;\n        if (!u) return;\n        function E() {\n          H(M.current, {\n            [w.Forwards]: () => {\n              var O, N, le;\n              if (!a.button) return;\n              let C = ve(),\n                R = C.indexOf(a.button),\n                e = C.slice(0, R + 1),\n                S = [...C.slice(R + 1), ...e];\n              for (let K of S.slice()) if (((N = (O = K == null ? void 0 : K.id) == null ? void 0 : O.startsWith) == null ? void 0 : N.call(O, \"headlessui-focus-sentinel-\")) || ((le = a.panel) == null ? void 0 : le.contains(K))) {\n                let ae = S.indexOf(K);\n                ae !== -1 && S.splice(ae, 1);\n              }\n              _(S, k.First, !1);\n            },\n            [w.Backwards]: () => _(u, k.Last)\n          });\n        }\n        E();\n      });\n    return F.createElement(ne.Provider, {\n      value: a.panelId\n    }, f && m && F.createElement(X, {\n      id: l,\n      ref: a.beforePanelSentinel,\n      features: Z.Focusable,\n      as: \"button\",\n      type: \"button\",\n      onFocus: L\n    }), j({\n      ourProps: A,\n      theirProps: d,\n      slot: y,\n      defaultTag: xe,\n      features: Ge,\n      visible: f,\n      name: \"Popover.Panel\"\n    }), f && m && F.createElement(X, {\n      id: v,\n      ref: a.afterPanelSentinel,\n      features: Z.Focusable,\n      as: \"button\",\n      type: \"button\",\n      onFocus: D\n    }));\n  }),\n  _e = \"div\",\n  we = W(function (t, c) {\n    let o = Y(null),\n      d = x(o, c),\n      [a, n] = Pe([]),\n      g = b(f => {\n        n(P => {\n          let y = P.indexOf(f);\n          if (y !== -1) {\n            let A = P.slice();\n            return A.splice(y, 1), A;\n          }\n          return P;\n        });\n      }),\n      m = b(f => (n(P => [...P, f]), () => g(f))),\n      l = b(() => {\n        var y;\n        let f = be(o);\n        if (!f) return !1;\n        let P = f.activeElement;\n        return (y = o.current) != null && y.contains(P) ? !0 : a.some(A => {\n          var M, L;\n          return ((M = f.getElementById(A.buttonId)) == null ? void 0 : M.contains(P)) || ((L = f.getElementById(A.panelId)) == null ? void 0 : L.contains(P));\n        });\n      }),\n      v = b(f => {\n        for (let P of a) P.buttonId !== f && P.close();\n      }),\n      p = I(() => ({\n        registerPopover: m,\n        unregisterPopover: g,\n        isFocusWithinPopoverGroup: l,\n        closeOthers: v\n      }), [m, g, l, v]),\n      B = I(() => ({}), []),\n      s = t,\n      T = {\n        ref: d\n      };\n    return F.createElement(re.Provider, {\n      value: p\n    }, j({\n      ourProps: T,\n      theirProps: s,\n      slot: B,\n      defaultTag: _e,\n      name: \"Popover.Group\"\n    }));\n  }),\n  mt = Object.assign(Fe, {\n    Button: Be,\n    Overlay: He,\n    Panel: ke,\n    Group: we\n  });\nexport { mt as Popover };","map":null,"metadata":{},"sourceType":"module"}